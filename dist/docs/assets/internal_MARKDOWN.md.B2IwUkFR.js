import{_ as n,c as t,o as r,ag as a}from"./chunks/framework.CffQSbY-.js";const u=JSON.parse('{"title":"Markdown Compose Mode - Remaining Work","description":"","frontmatter":{},"headers":[],"relativePath":"internal/MARKDOWN.md","filePath":"internal/MARKDOWN.md","lastUpdated":1766060490000}'),o={name:"internal/MARKDOWN.md"};function i(s,e,l,d,p,c){return r(),t("div",null,[...e[0]||(e[0]=[a('<h1 id="markdown-compose-mode-remaining-work" tabindex="-1">Markdown Compose Mode - Remaining Work <a class="header-anchor" href="#markdown-compose-mode-remaining-work" aria-label="Permalink to &quot;Markdown Compose Mode - Remaining Work&quot;">​</a></h1><p>Plugin: <code>plugins/markdown_compose.ts</code></p><h2 id="pending-features" tabindex="-1">Pending Features <a class="header-anchor" href="#pending-features" aria-label="Permalink to &quot;Pending Features&quot;">​</a></h2><h3 id="not-yet-started" tabindex="-1">Not Yet Started <a class="header-anchor" href="#not-yet-started" aria-label="Permalink to &quot;Not Yet Started&quot;">​</a></h3><ul><li><strong>Multi-pass transforms</strong>: design allows chaining; current implementation supports single transform per viewport</li><li><strong>Visual-line navigation</strong>: up/down should operate on display lines in Compose mode; currently behaves like Source mode</li><li><strong>Column guides rendering</strong>: stored in state but not drawn</li><li><strong>Context-sensitive Enter</strong>: Enter in compose mode should be context-aware (continue lists, add bullets, double-newline for paragraphs). Likely implemented via a compose-specific keybinding (e.g. <code>Action::PluginAction</code>) rather than “intercepting raw keys”.</li></ul><h3 id="partial-implementation" tabindex="-1">Partial Implementation <a class="header-anchor" href="#partial-implementation" aria-label="Permalink to &quot;Partial Implementation&quot;">​</a></h3><ul><li><strong>Wrapping as transform</strong>: wrapping happens in renderer, not as a token-inserting transform step. Plugins cannot control wrapping strategy</li><li><strong>Base token stream</strong>: renderer can build a base token stream for the viewport (used for plugin view transforms), but the “identity path” does not force tokens through an explicit multi-stage pipeline.</li></ul><h2 id="architecture-gap" tabindex="-1">Architecture Gap <a class="header-anchor" href="#architecture-gap" aria-label="Permalink to &quot;Architecture Gap&quot;">​</a></h2><p>The design envisions:</p><ol><li>Source → base token stream (Text/Newline/Space)</li><li>Plugin transforms rewrite tokens (Newline → Space for soft breaks)</li><li>Layout transform inserts break tokens for wrapping</li><li>Renderer draws final token stream</li></ol><p><strong>Current reality (as of current code)</strong>:</p><ul><li>The renderer fires <code>view_transform_request</code> during render and provides viewport tokens.</li><li>Plugin hooks are fire-and-forget (non-blocking); plugins respond by sending <code>PluginCommand::SubmitViewTransform</code>.</li><li>Plugin commands are drained in <code>Editor::process_async_messages()</code> before a later render, so view transforms are effectively applied on a subsequent frame (and may lag by a frame under load).</li><li>Line wrapping is still a renderer concern; plugins can shape tokens (e.g., inject soft breaks) but don’t own the wrapping algorithm end-to-end.</li></ul><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">​</a></h2><ol><li><strong>Column guides</strong>: render vertical lines at <code>compose_column_guides</code> positions</li><li><strong>Visual navigation</strong>: bind up/down to visual-line movement in Compose mode</li><li><strong>Markdown plugin</strong>: parse incrementally, rewrite paragraph newlines to spaces, emit structure styling, detect hard breaks</li></ol>',14)])])}const g=n(o,[["render",i]]);export{u as __pageData,g as default};
