import{_ as t,c as a,o as i,ag as o}from"./chunks/framework.CffQSbY-.js";const h=JSON.parse('{"title":"Paste Handling (Internal vs External)","description":"","frontmatter":{},"headers":[],"relativePath":"design/paste-handling.md","filePath":"design/paste-handling.md","lastUpdated":1767757023000}'),n={name:"design/paste-handling.md"};function l(s,e,r,c,d,u){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="paste-handling-internal-vs-external" tabindex="-1">Paste Handling (Internal vs External) <a class="header-anchor" href="#paste-handling-internal-vs-external" aria-label="Permalink to &quot;Paste Handling (Internal vs External)&quot;">​</a></h1><p>Fresh currently has two distinct “paste” paths:</p><ol><li><p><strong>Internal paste</strong> (editor action <code>Paste</code>, e.g. <code>Ctrl+V</code> or menu <code>Edit -&gt; Paste</code>)</p><ul><li>Fresh can fetch clipboard contents and apply it as a single edit event.</li><li>Result: a single undo step reverses the whole paste.</li></ul></li><li><p><strong>External terminal paste</strong> (often <code>Ctrl+Shift+V</code>)</p><ul><li>Fresh does <strong>not</strong> control this.</li><li>Many terminals send this as a rapid stream of key events (e.g. <code>KeyCode::Char(_)</code>), which currently becomes many independent edit events/undo steps.</li></ul></li></ol><p>Issue: #372 — external paste should behave more like internal paste in undo history.</p><h2 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to &quot;Goals&quot;">​</a></h2><ul><li>Detect external paste when possible and apply it as <strong>one undoable edit</strong>.</li><li>Avoid character-by-character paste behavior (auto-close, skip-over, auto-indent quirks) when pasting large text.</li><li>Keep normal typing behavior (undo granularity, auto-close, etc.) unchanged.</li><li>Provide a best-effort fallback for terminals that cannot reliably mark paste.</li></ul><h2 id="best-detection-bracketed-paste-reliable" tabindex="-1">Best detection: “bracketed paste” (reliable) <a class="header-anchor" href="#best-detection-bracketed-paste-reliable" aria-label="Permalink to &quot;Best detection: “bracketed paste” (reliable)&quot;">​</a></h2><p>Many terminals support <strong>bracketed paste mode</strong>, where pasted content is wrapped in escape sequences. When the application enables bracketed paste mode, input libraries can surface paste as a single event.</p><p>Fresh already has evidence that <code>crossterm</code> can surface this as <code>Event::Paste(String)</code>:</p><ul><li><code>src/bin/event_debug.rs</code> prints <code>Event::Paste(text)</code></li></ul><h3 id="design" tabindex="-1">Design <a class="header-anchor" href="#design" aria-label="Permalink to &quot;Design&quot;">​</a></h3><ol><li><p><strong>Enable bracketed paste on startup</strong></p><ul><li>When supported, this causes external paste (e.g. <code>Ctrl+Shift+V</code>) to arrive as a distinct “paste” event rather than a stream of keypresses.</li></ul></li><li><p><strong>Handle <code>CrosstermEvent::Paste(text)</code> in the main loop</strong></p><ul><li>The main event loop (<code>src/main.rs</code> <code>run_event_loop_common</code>) currently only handles <code>Key/Mouse/Resize</code> and ignores other <code>CrosstermEvent</code> variants.</li><li>Add handling for paste events and route them to the editor as a single atomic edit.</li></ul></li><li><p><strong>Insert as one undo step</strong></p><ul><li>Insert the entire <code>text</code> with one undoable entry: <ul><li>Single cursor: one <code>Event::Insert { text, ... }</code></li><li>Multi-cursor and/or selection deletion: one <code>Event::Batch { events, description }</code></li></ul></li><li>This reuses existing undo semantics: <code>Event::Batch</code> is undone/redone atomically (<code>src/model/event.rs</code>).</li></ul></li></ol><h3 id="behavioral-notes" tabindex="-1">Behavioral notes <a class="header-anchor" href="#behavioral-notes" aria-label="Permalink to &quot;Behavioral notes&quot;">​</a></h3><ul><li>Paste insertion should avoid character-level auto-edit behaviors (auto-close delimiters, skip-over, etc.) that are desirable for typing but often undesirable for bulk paste.</li><li>Newline/tab handling is naturally correct because the paste event includes the literal text.</li></ul><h2 id="fallback-burst-coalescing-heuristic-best-effort" tabindex="-1">Fallback: burst coalescing heuristic (best-effort) <a class="header-anchor" href="#fallback-burst-coalescing-heuristic-best-effort" aria-label="Permalink to &quot;Fallback: burst coalescing heuristic (best-effort)&quot;">​</a></h2><p>If bracketed paste is unavailable, external paste may still be indistinguishable from “very fast typing” because it arrives as a stream of <code>KeyCode::Char(_)</code> events.</p><p>In this case, the best practical option is a heuristic: coalesce a burst of fast character input into one edit.</p><h3 id="heuristic-proposal" tabindex="-1">Heuristic proposal <a class="header-anchor" href="#heuristic-proposal" aria-label="Permalink to &quot;Heuristic proposal&quot;">​</a></h3><ul><li>Maintain a short-lived buffer of “textual” keypresses in the event loop: <ul><li>Typically <code>KeyCode::Char(c)</code> with no modifiers.</li><li>Optionally include <code>Enter</code> → <code>&#39;\\n&#39;</code> and <code>Tab</code> → <code>&#39;\\t&#39;</code> if desired.</li></ul></li><li>Treat input as a paste-burst when <strong>both</strong> are true: <ul><li>Inter-key gaps are extremely small (e.g. <code>&lt;= 2–5ms</code>)</li><li>Burst length crosses a minimum (e.g. <code>&gt;= 8–16 chars</code>)</li></ul></li><li>Flush the buffer immediately when: <ul><li>A non-text key arrives (navigation, delete, etc.)</li><li>Any mouse/resize event arrives</li><li>UI context changes (prompt/menu/settings/popup)</li><li>The time gap exceeds the threshold</li></ul></li><li>When flushing: <ul><li>Apply the buffered text via the same “atomic insert” path used by bracketed paste (single undo step).</li></ul></li></ul><h3 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h3><ul><li>This can never be perfect: extremely fast typists or keyboard macros may be misclassified as paste.</li><li>Bracketed paste remains the preferred, robust solution.</li></ul><h2 id="atomic-insert-api-recommended-internal-abstraction" tabindex="-1">“Atomic insert” API (recommended internal abstraction) <a class="header-anchor" href="#atomic-insert-api-recommended-internal-abstraction" aria-label="Permalink to &quot;“Atomic insert” API (recommended internal abstraction)&quot;">​</a></h2><p>To keep paste behavior consistent across internal paste, bracketed paste, and heuristic coalescing, define a single editor-level entrypoint such as:</p><ul><li><code>insert_text_atomic(text, description, source)</code></li></ul><p>Where <code>source</code> might distinguish:</p><ul><li><code>InternalPaste</code> (clipboard-driven)</li><li><code>ExternalPaste</code> (bracketed paste event)</li><li><code>CoalescedInput</code> (heuristic)</li></ul><p>Responsibilities of the atomic insert path:</p><ul><li>Delete selections (if any) before inserting.</li><li>Insert the entire string as one undoable entry (<code>Event::Insert</code> or <code>Event::Batch</code>).</li><li>Ensure all cross-cutting concerns run through the normal event path: <ul><li>Use <code>Editor::apply_event_to_active_buffer(...)</code> so LSP, plugin hooks, layout invalidation, etc. remain consistent (<code>src/app/mod.rs</code>).</li></ul></li></ul><h2 id="suggested-configuration-knobs" tabindex="-1">Suggested configuration knobs <a class="header-anchor" href="#suggested-configuration-knobs" aria-label="Permalink to &quot;Suggested configuration knobs&quot;">​</a></h2><p>To keep behavior tunable across terminals and preferences:</p><ul><li><code>editor.enable_bracketed_paste</code> (default: true)</li><li><code>editor.external_paste_coalesce</code> (default: true)</li><li><code>editor.external_paste_min_chars</code> (default: 16)</li><li><code>editor.external_paste_max_inter_key_ms</code> (default: 3)</li><li>Optional: <code>editor.external_paste_max_total_ms</code> (cap to avoid pathological grouping)</li></ul><h2 id="implementation-touchpoints-for-372" tabindex="-1">Implementation touchpoints (for #372) <a class="header-anchor" href="#implementation-touchpoints-for-372" aria-label="Permalink to &quot;Implementation touchpoints (for #372)&quot;">​</a></h2><ul><li><code>src/main.rs</code><ul><li>Handle <code>CrosstermEvent::Paste(text)</code> in <code>run_event_loop_common</code>.</li><li>(If needed) enable bracketed paste mode during terminal setup/teardown.</li></ul></li><li><code>src/app/*</code><ul><li>Add an editor API to apply an “atomic insert” (single undo entry) for paste-like input sources.</li></ul></li><li><code>src/model/event.rs</code><ul><li>No new primitives required; <code>Event::Batch</code> already provides atomic undo/redo.</li></ul></li></ul>',33)])])}const m=t(n,[["render",l]]);export{h as __pageData,m as default};
