import{_ as i,c as t,o,ag as n}from"./chunks/framework.CffQSbY-.js";const h=JSON.parse('{"title":"Fresh Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"development/architecture.md","filePath":"development/architecture.md","lastUpdated":1767757023000}'),a={name:"development/architecture.md"};function r(s,e,l,d,c,p){return o(),t("div",null,[...e[0]||(e[0]=[n('<h1 id="fresh-architecture" tabindex="-1">Fresh Architecture <a class="header-anchor" href="#fresh-architecture" aria-label="Permalink to &quot;Fresh Architecture&quot;">​</a></h1><p>Fresh is a high-performance terminal-based text editor written in Rust. This document describes the runtime structure and the core “flow” concepts: event loop, input handling, actions vs events, state ownership, rendering, and plugins.</p><h2 id="runtime-model" tabindex="-1">Runtime Model <a class="header-anchor" href="#runtime-model" aria-label="Permalink to &quot;Runtime Model&quot;">​</a></h2><p>Fresh runs a synchronous main thread and communicates with background workers:</p><ul><li><strong>Main thread:</strong> terminal input, frame loop, state mutation, rendering.</li><li><strong>Tokio runtime / background tasks:</strong> LSP, file I/O, terminal PTY I/O, directory refresh.</li><li><strong>Plugin thread (TypeScript runtime):</strong> executes hooks/actions and sends <code>PluginCommand</code>s back to the editor.</li></ul><p>Key entrypoint: <code>src/main.rs</code></p><h2 id="main-event-loop" tabindex="-1">Main Event Loop <a class="header-anchor" href="#main-event-loop" aria-label="Permalink to &quot;Main Event Loop&quot;">​</a></h2><p>The main loop is a fixed-timestep-ish render loop (~60fps target) that interleaves:</p><ol><li>Drain async work/results (<code>Editor::process_async_messages</code>)</li><li>Time-based checks (hover timers, warning log, auto-save, polling file changes)</li><li>Render when needed (<code>Editor::render</code>)</li><li>Poll terminal input (keyboard/mouse/resize)</li></ol><p>Key file: <code>src/main.rs</code></p><h2 id="input-handling" tabindex="-1">Input Handling <a class="header-anchor" href="#input-handling" aria-label="Permalink to &quot;Input Handling&quot;">​</a></h2><h3 id="terminal-input-events" tabindex="-1">Terminal Input Events <a class="header-anchor" href="#terminal-input-events" aria-label="Permalink to &quot;Terminal Input Events&quot;">​</a></h3><p>The terminal produces <code>crossterm::event::Event</code> values:</p><ul><li>key press events</li><li>mouse events (click/drag/move/scroll)</li><li>resize events</li></ul><p>The main loop routes these into <code>Editor</code>:</p><ul><li>keys → <code>Editor::handle_key</code> (<code>src/app/input.rs</code>)</li><li>mouse → <code>Editor::handle_mouse</code> (<code>src/app/mouse_input.rs</code>)</li></ul><h3 id="modal-dispatch-settings-menu-prompt-popup" tabindex="-1">Modal Dispatch (Settings/Menu/Prompt/Popup) <a class="header-anchor" href="#modal-dispatch-settings-menu-prompt-popup" aria-label="Permalink to &quot;Modal Dispatch (Settings/Menu/Prompt/Popup)&quot;">​</a></h3><p>Keyboard input has a strict priority order for “modal” UI:</p><ol><li>Settings</li><li>Menu</li><li>Prompt (including file browser prompts)</li><li>Popup</li><li>Normal/FileExplorer/Terminal contexts</li></ol><p>Modal components implement a small hierarchical <code>InputHandler</code> trait and return deferred work (<code>DeferredAction</code>) that the <code>Editor</code> executes after dispatch.</p><p>Key files:</p><ul><li>Dispatch glue: <code>src/app/input_dispatch.rs</code></li><li>Input handler primitives: <code>src/input/handler.rs</code></li><li>Prompt: <code>src/view/prompt_input.rs</code></li><li>Menu: <code>src/view/ui/menu_input.rs</code></li><li>Popup: <code>src/view/popup_input.rs</code></li></ul><h3 id="key-contexts-and-keybindings" tabindex="-1">Key Contexts and Keybindings <a class="header-anchor" href="#key-contexts-and-keybindings" aria-label="Permalink to &quot;Key Contexts and Keybindings&quot;">​</a></h3><p>When no modal consumes input, keys resolve to an editor <code>Action</code>:</p><ul><li><code>KeyContext</code> determines which keymap applies (global vs normal vs prompt vs popup, etc.)</li><li>chord sequences are supported (multi-key bindings)</li><li>context fallthrough is limited to “application-wide” actions to prevent leakage from modals</li></ul><p>Key file: <code>src/input/keybindings.rs</code></p><h2 id="actions-vs-events-core-concepts" tabindex="-1">Actions vs Events (Core Concepts) <a class="header-anchor" href="#actions-vs-events-core-concepts" aria-label="Permalink to &quot;Actions vs Events (Core Concepts)&quot;">​</a></h2><p>Fresh has two distinct layers that are easy to conflate:</p><h3 id="action-intent" tabindex="-1"><code>Action</code> (Intent) <a class="header-anchor" href="#action-intent" aria-label="Permalink to &quot;`Action` (Intent)&quot;">​</a></h3><p><code>crate::input::keybindings::Action</code> is the “what the user wants” layer:</p><ul><li>examples: <code>Save</code>, <code>CommandPalette</code>, <code>MoveLeft</code>, <code>InsertChar(&#39;a&#39;)</code>, <code>LspHover</code>, <code>PluginAction(...)</code></li><li>produced by keybindings, menus, command palette, and some UI handlers</li></ul><p>Execution entrypoint: <code>Editor::handle_action</code> (<code>src/app/input.rs</code>)</p><h3 id="event-state-change-undo-redo" tabindex="-1"><code>Event</code> (State Change + Undo/Redo) <a class="header-anchor" href="#event-state-change-undo-redo" aria-label="Permalink to &quot;`Event` (State Change + Undo/Redo)&quot;">​</a></h3><p><code>crate::model::event::Event</code> is the event-sourced “what changed” layer for undoable mutations:</p><ul><li>examples: <code>Insert</code>, <code>Delete</code>, <code>MoveCursor</code>, <code>AddCursor</code>, <code>Batch</code>, plus some view events</li><li>stored in a per-buffer <code>EventLog</code> for undo/redo and “modified since saved” tracking</li></ul><p>Key files:</p><ul><li>Event definitions + event log: <code>src/model/event.rs</code></li><li>Undo/redo application: <code>src/app/undo_actions.rs</code></li></ul><h3 id="action-→-event-conversion" tabindex="-1">Action → Event Conversion <a class="header-anchor" href="#action-→-event-conversion" aria-label="Permalink to &quot;Action → Event Conversion&quot;">​</a></h3><p>Many editing/navigation actions convert into one or more <code>Event</code>s via:</p><ul><li><code>src/input/actions.rs</code> (pure conversion logic)</li><li><code>Editor::action_to_events</code> (<code>src/app/render.rs</code>) as a convenience wrapper</li></ul><p>Multi-cursor edits typically become <code>Event::Batch</code> so undo is atomic.</p><h3 id="centralized-event-application" tabindex="-1">Centralized Event Application <a class="header-anchor" href="#centralized-event-application" aria-label="Permalink to &quot;Centralized Event Application&quot;">​</a></h3><p>All undoable buffer mutations should go through:</p><ul><li><code>Editor::apply_event_to_active_buffer</code> (<code>src/app/mod.rs</code>)</li></ul><p>This method centralizes cross-cutting concerns:</p><ul><li>apply to <code>EditorState</code></li><li>sync cursor state into active split view state</li><li>invalidate layouts for splits viewing the buffer</li><li>adjust cursors in other splits viewing the same buffer</li><li>clear/update search highlights appropriately</li><li>fire plugin hooks for edits</li><li>send LSP change notifications using pre-computed positions</li></ul><p>Key file: <code>src/app/mod.rs</code></p><h2 id="state-ownership-buffer-vs-view" tabindex="-1">State Ownership: Buffer vs View <a class="header-anchor" href="#state-ownership-buffer-vs-view" aria-label="Permalink to &quot;State Ownership: Buffer vs View&quot;">​</a></h2><p>Fresh separates shared buffer state from per-split view state:</p><h3 id="buffer-state-shared-per-buffer" tabindex="-1">Buffer State (shared per buffer) <a class="header-anchor" href="#buffer-state-shared-per-buffer" aria-label="Permalink to &quot;Buffer State (shared per buffer)&quot;">​</a></h3><p><code>EditorState</code> owns “the document” and content-anchored decorations:</p><ul><li>text buffer</li><li>cursors (authoritative positions)</li><li>overlays, margins, virtual text</li><li>syntax/semantic highlighting caches</li></ul><p>Key file: <code>src/state.rs</code></p><h3 id="view-state-per-split" tabindex="-1">View State (per split) <a class="header-anchor" href="#view-state-per-split" aria-label="Permalink to &quot;View State (per split)&quot;">​</a></h3><p><code>SplitViewState</code> owns “how it’s displayed in this split”:</p><ul><li>viewport (scroll position, wrap mode, dimensions)</li><li>a copy of cursors for hit testing / render bookkeeping</li><li>optional <code>view_transform</code> payload (plugin-provided token stream)</li><li>compose settings (width, column guides)</li></ul><p>Key file: <code>src/view/split.rs</code></p><p>View-only events (scrolling, recentering, set viewport) are applied at the <code>Editor</code>/split layer; buffer events (insert/delete/etc.) are applied to <code>EditorState</code>.</p><h2 id="async-messages-lsp-plugins-file-watching-terminals" tabindex="-1">Async Messages (LSP, Plugins, File Watching, Terminals) <a class="header-anchor" href="#async-messages-lsp-plugins-file-watching-terminals" aria-label="Permalink to &quot;Async Messages (LSP, Plugins, File Watching, Terminals)&quot;">​</a></h2><p>Every main-loop iteration drains async results via:</p><ul><li><code>Editor::process_async_messages</code> (<code>src/app/mod.rs</code>)</li></ul><p>This processes:</p><ul><li>LSP results/diagnostics (via the async bridge)</li><li>plugin commands (<code>PluginCommand</code>) from the plugin thread</li><li>terminal output/exits, file-open directory loads, file tree refresh, etc.</li></ul><p>Key files:</p><ul><li>Message handling: <code>src/app/async_messages.rs</code></li><li>LSP handlers: <code>src/app/async_messages.rs</code> and <code>src/app/lsp_actions.rs</code></li></ul><h2 id="rendering-pipeline-overview" tabindex="-1">Rendering Pipeline (Overview) <a class="header-anchor" href="#rendering-pipeline-overview" aria-label="Permalink to &quot;Rendering Pipeline (Overview)&quot;">​</a></h2><p>Rendering is designed to preserve source-byte → screen-cell mappings for cursors and hit testing:</p><ol><li>Determine viewport per split (scroll + size)</li><li>Build base tokens for visible bytes</li><li>(Optional) apply per-split <code>view_transform</code> tokens if present</li><li>Generate view lines + mappings</li><li>Apply styling layers (syntax/semantic, selection, overlays, etc.)</li><li>Emit ratatui widgets</li></ol><p>Key files:</p><ul><li>High-level render + hook emission: <code>src/app/render.rs</code></li><li>Split rendering and tokenization: <code>src/view/ui/split_rendering.rs</code></li><li>View line generation: <code>src/view/ui/view_pipeline.rs</code></li></ul><h2 id="plugins-updated-timing-model" tabindex="-1">Plugins (Updated Timing Model) <a class="header-anchor" href="#plugins-updated-timing-model" aria-label="Permalink to &quot;Plugins (Updated Timing Model)&quot;">​</a></h2><p>Plugins run on a separate thread. The editor interacts with plugins through:</p><ul><li><strong>Hooks:</strong> <code>plugin_manager.run_hook(...)</code> queues work to the plugin thread (non-blocking).</li><li><strong>Commands:</strong> plugins send <code>PluginCommand</code>s back to the editor, which are applied when the main thread drains them during <code>process_async_messages()</code>.</li></ul><p>Implications:</p><ul><li>Hooks do not block rendering.</li><li>Effects like <code>SubmitViewTransform</code>, overlays, virtual text, etc. may become visible on a later frame (typically the next frame).</li></ul><p>Key files:</p><ul><li>Plugin manager facade: <code>src/services/plugins/manager.rs</code></li><li>Plugin thread interface: <code>src/services/plugins/thread.rs</code></li><li>Hook definitions: <code>src/services/plugins/hooks.rs</code></li><li>Plugin command handling: <code>src/app/mod.rs</code>, <code>src/app/plugin_commands.rs</code>, <code>src/app/async_messages.rs</code></li></ul>',77)])])}const m=i(a,[["render",r]]);export{h as __pageData,m as default};
