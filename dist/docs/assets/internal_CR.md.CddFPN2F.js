import{_ as i,c as r,o,ag as n}from"./chunks/framework.CffQSbY-.js";const g=JSON.parse('{"title":"Code Review","description":"","frontmatter":{},"headers":[],"relativePath":"internal/CR.md","filePath":"internal/CR.md","lastUpdated":1766060490000}'),s={name:"internal/CR.md"};function t(a,e,l,c,d,u){return o(),r("div",null,[...e[0]||(e[0]=[n('<h1 id="code-review" tabindex="-1">Code Review <a class="header-anchor" href="#code-review" aria-label="Permalink to &quot;Code Review&quot;">​</a></h1><p>Pending code quality improvements and refactoring opportunities.</p><p>Note: file/line references are best-effort and can drift as the code changes; treat line numbers as approximate.</p><h2 id="large-functions" tabindex="-1">Large Functions <a class="header-anchor" href="#large-functions" aria-label="Permalink to &quot;Large Functions&quot;">​</a></h2><ul><li>src/app/render.rs:5 — top-level <code>render</code> runs ~450 lines covering layout calculation, plugin hook firing, file explorer rendering, and status/prompt UI. The amount of responsibility in one function hurts readability and testing; factoring into helpers (layout, plugin hook prep, explorer rendering, status/prompt rendering) would make regressions easier to spot.</li><li>src/input/keybindings.rs:376 — <code>Action::from_str</code> is a ~260-line string-to-enum match. A data-driven table would reduce boilerplate and avoid missing new actions when added to the enum.</li><li>src/input/commands.rs:89 — <code>get_all_commands</code> is a ~540-line literal list in one function. This is brittle to maintain (hard to diff/review additions) and couples command metadata to code; consider a data table or config-driven source with tests for completeness.</li><li>src/primitives/highlighter.rs:78 — <code>highlight_config</code> is ~450 lines of repetitive per-language setup; moving to a data table (language -&gt; queries/config) would reduce duplication and make it harder to forget highlight names when adding languages.</li><li>src/config.rs:566 — <code>default_menus</code> is a 420-line literal definition. Consider moving menu data to structured config or a table to make changes easier to diff/test and to avoid bloating code with data.</li><li>src/view/viewport.rs:521 — <code>ensure_visible</code> runs ~230 lines of layout math and clamping in one method; breaking into smaller helpers (e.g., horizontal/vertical logic, scroll computations) would make correctness checks and future changes safer.</li><li>src/input/keybindings.rs:1196 — <code>format_action</code> spans ~200 lines mirroring <code>from_str</code>; another sign a data-driven action registry would reduce duplication and risk of drift.</li><li>src/view/ui/view_pipeline.rs:134 — <code>next</code> is a 160+ line iterator step that handles multiple line types and wrapping; decomposing per-case helpers would make it easier to verify wrapping and newline behaviors.</li><li>src/model/buffer.rs:575 — <code>get_text_range_mut</code> is a 160+ line method with intertwined chunk handling, file streaming, and cache management. The dense control flow increases the risk of off-by-one or range bugs; extract helpers per buffer variant (loaded vs unloaded) and centralize bounds checks.</li><li>src/services/plugins/runtime.rs:1861/1967/2066/2143/2159/etc. — repeated <code>pending_responses.lock().unwrap()</code> (and other mutex <code>unwrap()</code>s) in ops will panic if the mutex is poisoned by a plugin panic. These should handle poisoning and return an error to the plugin rather than crashing the runtime.</li><li>src/view/ui/file_explorer.rs:148 — renderer calls <code>view.tree().get_node(node_id).expect(&quot;Node should exist&quot;)</code>. A desynced tree (e.g., after FS errors or refresh races) will panic the UI; prefer graceful fallback or placeholder row.</li><li>src/view/file_tree/tree.rs:138 — <code>expand_node</code> uses <code>self.get_node(id).unwrap()</code> while doing async FS reads. If the node was removed between calls, this panics instead of returning an IO error; return a proper error for missing nodes to avoid crashing the explorer.</li><li>src/view/ui/status_bar.rs:149 — <code>render_status</code> pulls cursor info with ad-hoc line iteration and cached line numbers in a long method; consider extracting helpers for cursor position and diagnostics summary to reduce the ~200-line render method complexity.</li><li>src/model/cursor.rs:220 — <code>primary()</code>/<code>primary_mut()</code> use <code>expect(&quot;Primary cursor should always exist&quot;)</code>. If a bug ever removes the primary cursor (e.g., during multi-cursor deletion), the editor will panic. Prefer returning an error or recreating a primary cursor to keep the UI alive.</li><li>src/model/marker_tree.rs:494/509/512/517/etc. — AVL rotations and queries use unchecked <code>unwrap()</code> on child pointers. Any tree corruption (e.g., from earlier logic bugs) will panic. Consider defensive checks or debug assertions gated for release builds to avoid crashing the editor.</li><li>src/view/split.rs:162 — <code>ensure_layout</code> returns <code>self.layout.as_ref().unwrap()</code>. If callers forget to call <code>ensure_layout</code> before <code>get_layout</code> usage, rendering will panic. Consider returning <code>Option&lt;&amp;Layout&gt;</code> or asserting via a Result to make misuse harder in production.</li><li>src/view/ui/split_rendering.rs:1642/1838 — rendering paths <code>unwrap()</code> optional highlight colors/positions when overlays and syntax spans overlap. If the lookups ever return <code>None</code> (e.g., missing semantic span), the renderer will panic; handle <code>None</code> with defaults to keep the UI resilient.</li><li>src/view/prompt.rs:974 — <code>selected_text().unwrap()</code> in selection paths; production prompt operations should avoid panics when no selection exists (e.g., racey UI updates or plugin-driven prompt changes).</li><li>src/input/buffer_mode.rs: ModeRegistry and BufferMode rely on string names without validation; missing mode references during inheritance or resolve silently stop traversal, which can mask misconfigurations. Consider explicit errors/logging for unknown parent/mode to aid debugging.</li><li>src/view/viewport.rs:895 — <code>ensure_cursors_visible</code> unwraps min/max cursor positions; if called with an empty cursor list (due to upstream logic bugs), it will panic. Guard against empty input to keep scrolling resilient.</li><li>src/view/ui/suggestions.rs:80/87 — width calculations use <code>.max().unwrap_or(0)</code> on suggestion lists; if any suggestion text/keybinding is extremely wide, width computation and rendering alignment are packed into the main render function. Consider extracting layout calculation and handling unreasonably wide strings to avoid overflow/panic in rendering math.</li><li>src/services/signal_handler.rs:23/104 — global backtrace storage uses <code>Mutex::lock().unwrap()</code>; any poisoning (e.g., panic during signal handling) will panic again. Signal handlers should avoid unwraps and degrade gracefully to prevent double panics during shutdown.</li><li>src/services/async_bridge.rs:300/324/329/356/... — multiple <code>unwrap()</code>s on channel send/recv in the bridge; if the channel is closed (e.g., runtime shutdown), the bridge will panic instead of allowing a clean exit. Return errors and let the main loop terminate gracefully.</li><li>src/services/process_limits.rs:405/406/459/476/496/503 — heavy use of <code>unwrap()</code> around serialization and system resource reads; a failure to read system memory or serialize limits will panic instead of bubbling a configuration error. Prefer error propagation.</li><li>src/services/plugins/api.rs &amp; event_hooks/process: widespread <code>RwLock::unwrap()</code> and channel <code>unwrap()</code>s. A poisoned lock or closed channel will panic plugins and potentially the editor. Replace with error paths that surface to the plugin caller or log-and-drop to keep the host stable.</li><li>src/input/command_registry.rs — plugin command registration/history uses <code>RwLock::unwrap()</code> in production paths; a poisoned lock (plugin panic) will crash the editor. Handle lock errors and surface failures to plugins.</li><li>src/input/actions.rs:68 — block selection reads <code>cursor.block_anchor.unwrap()</code> when in block mode; if state enters block mode without an anchor, movement will panic. Guard against None to keep editing stable.</li><li>src/services/plugins/process.rs:132/166/195/226 — plugin process bridge uses <code>recv().unwrap()</code>; closed channels during shutdown will panic the host. Treat channel closure as cancellation to allow clean teardown.</li><li>src/services/plugins/process.rs — blocking <code>recv()</code> loops have no timeout/backoff; a misbehaving plugin can hang the thread. Consider async or timeout-aware handling to avoid host hangs.</li><li>src/services/async_bridge.rs — uses unbounded std::sync::mpsc channels with no backpressure or eviction; a burst of async messages (e.g., LSP floods) can grow memory unbounded. Consider bounded channels or dropping strategies plus explicit error propagation on lock/channel failure.</li><li>src/services/plugins/event_hooks.rs — <code>apply_event_with_hooks</code> appears to be legacy/test-only and is not part of the current editor edit path (which applies edits via <code>Editor::apply_event_to_active_buffer</code> and queues plugin hooks asynchronously). If this module becomes production-critical again, it should isolate hook execution (catch_unwind/log) and avoid panics on poisoned locks.</li><li>src/app/plugin_commands.rs — some plugin text-editing commands (<code>InsertText</code>, <code>DeleteRange</code>, <code>InsertAtCursor</code>) mutate buffers without going through <code>Editor::apply_event_to_active_buffer</code>, which can bypass cross-cutting concerns (LSP change notifications, search highlight clearing, cursor/view sync, plugin after-insert/delete hooks). Consider routing “real edit” plugin commands through the centralized apply path, or document them as “raw/unsafe” edits.</li><li>src/view/ui/tabs.rs — <code>render_for_split</code> packs tab width calculation, scroll computation, and rendering into one long function; consider splitting into layout calculation and render steps to improve readability and reduce bugs in scroll math.</li><li>src/services/process_limits.rs — applies limits via cgroups/setrlimit with many unwraps noted; also lacks clear fallback/reporting when limits can&#39;t be applied (e.g., non-Linux or missing cgroup perms). Return actionable errors so callers can decide to continue without limits.</li></ul><h2 id="test-code" tabindex="-1">Test Code <a class="header-anchor" href="#test-code" aria-label="Permalink to &quot;Test Code&quot;">​</a></h2><ul><li>src/view/ui/menu.rs:655/776/811/830 — menu parsing/rendering tests use <code>unwrap()</code>; production parsing should handle malformed plugin menu contributions gracefully.</li><li>src/services/fs/slow.rs — tests use <code>TempDir::new().unwrap()</code>/<code>read_dir().await</code> unwraps; ensure production slow backend surfaces IO errors cleanly.</li><li>src/view/popup.rs — selection tests <code>unwrap()</code> the selected item; production popup handling should guard empty lists.</li></ul>',7)])])}const h=i(s,[["render",t]]);export{g as __pageData,h as default};
