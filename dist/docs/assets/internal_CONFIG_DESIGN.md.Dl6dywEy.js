import{_ as t,c as i,o as s,ag as a}from"./chunks/framework.CffQSbY-.js";const p=JSON.parse('{"title":"Fresh Editor Configuration System Design","description":"","frontmatter":{},"headers":[],"relativePath":"internal/CONFIG_DESIGN.md","filePath":"internal/CONFIG_DESIGN.md","lastUpdated":1767132355000}'),n={name:"internal/CONFIG_DESIGN.md"};function l(o,e,r,d,h,c){return s(),i("div",null,[...e[0]||(e[0]=[a(`<h1 id="fresh-editor-configuration-system-design" tabindex="-1">Fresh Editor Configuration System Design <a class="header-anchor" href="#fresh-editor-configuration-system-design" aria-label="Permalink to &quot;Fresh Editor Configuration System Design&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>This document outlines the design for the next generation of the Fresh editor&#39;s configuration system. The current implementation relies on a single merged <code>Config</code> struct loaded from JSON, which lacks the flexibility of multi-layered overrides (System vs User vs Project) and robust &quot;dual-writer&quot; support.</p><p>The new design implements a <strong>4-Level Overlay Architecture</strong> with <strong>Recursive Merging</strong>, utilizing standard <strong>JSON</strong> as the primary configuration format.</p><h2 id="architectural-goals" tabindex="-1">Architectural Goals <a class="header-anchor" href="#architectural-goals" aria-label="Permalink to &quot;Architectural Goals&quot;">​</a></h2><ol><li><strong>4-Level Hierarchy</strong>: Clearly distinguish between System (defaults), User (global), Project (local), and Session (volatile) settings.</li><li><strong>Deep Merging</strong>: recursive merging of configuration objects (maps/lists) rather than simple replacement.</li><li><strong>Minimal Persistence</strong>: Only save the <em>delta</em> (changes) from the layer below.</li><li><strong>Simplicity</strong>: Use standard JSON to ensure maximum compatibility and ease of implementation.</li><li><strong>Schema Evolution</strong>: Robust versioning and migration strategy.</li></ol><h2 id="_1-the-4-level-overlay-semantics" tabindex="-1">1. The 4-Level Overlay Semantics <a class="header-anchor" href="#_1-the-4-level-overlay-semantics" aria-label="Permalink to &quot;1. The 4-Level Overlay Semantics&quot;">​</a></h2><p>The configuration will be resolved by merging layers in the following order (lowest to highest precedence):</p><table tabindex="0"><thead><tr><th style="text-align:left;">Level</th><th style="text-align:left;">Source</th><th style="text-align:left;">Path (Linux/macOS)</th><th style="text-align:left;">Purpose</th><th style="text-align:left;">Mutability</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>1. System</strong></td><td style="text-align:left;">Embedded Binary</td><td style="text-align:left;"><code>src/config.rs</code> (Hardcoded)</td><td style="text-align:left;">Immutable defaults for all users.</td><td style="text-align:left;">Read-Only</td></tr><tr><td style="text-align:left;"><strong>2. User</strong></td><td style="text-align:left;">Global File</td><td style="text-align:left;"><code>~/.config/fresh/config.json</code></td><td style="text-align:left;">User preferences (theme, keymaps).</td><td style="text-align:left;">Read/Write</td></tr><tr><td style="text-align:left;"><strong>3. Project</strong></td><td style="text-align:left;">Local File</td><td style="text-align:left;"><code>$PROJECT_ROOT/.fresh/config.json</code></td><td style="text-align:left;">Project-specific overrides (indentation, build commands).</td><td style="text-align:left;">Read/Write</td></tr><tr><td style="text-align:left;"><strong>4. Session</strong></td><td style="text-align:left;">Runtime/Volatile</td><td style="text-align:left;">Memory / <code>.fresh/session.json</code></td><td style="text-align:left;">Temporary state (open files, cursor pos).</td><td style="text-align:left;">Read/Write</td></tr></tbody></table><p><strong>Resolution Logic:</strong><code>EffectiveConfig = Merge(System, Merge(User, Merge(Project, Session)))</code></p><h3 id="multi-root-workspaces-future" tabindex="-1">Multi-Root Workspaces (Future) <a class="header-anchor" href="#multi-root-workspaces-future" aria-label="Permalink to &quot;Multi-Root Workspaces (Future)&quot;">​</a></h3><p>For multi-root workspaces, a 5th level &quot;Workspace&quot; can be inserted between User and Project.</p><h2 id="_2-merging-strategy" tabindex="-1">2. Merging Strategy <a class="header-anchor" href="#_2-merging-strategy" aria-label="Permalink to &quot;2. Merging Strategy&quot;">​</a></h2><p>The system will employ a <strong>Deep Merge</strong> strategy:</p><ul><li><strong>Scalars (Int, Bool, String)</strong>: Higher precedence overwrites lower precedence.</li><li><strong>Maps (HashMap/Objects)</strong>: Recursively merged. Keys present in higher precedence override keys in lower. New keys are added.</li><li><strong>Lists (Arrays)</strong>: Replace by default. (A new list in Project replaces the User list).</li></ul><h3 id="rust-implementation-pattern" tabindex="-1">Rust Implementation Pattern <a class="header-anchor" href="#rust-implementation-pattern" aria-label="Permalink to &quot;Rust Implementation Pattern&quot;">​</a></h3><p>We will split the current <code>Config</code> struct into:</p><ol><li><code>PartialConfig</code>: A struct where all fields are <code>Option&lt;T&gt;</code>, representing a layer that <em>might</em> define values.</li><li><code>ResolvedConfig</code>: The final struct (similar to current <code>Config</code>) where all fields are concrete types.</li></ol><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Represents a single layer (User, Project, etc.)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[derive(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deserialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PartialConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    theme</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    editor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PartialEditorConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Represents the final merged state used by the editor</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    theme</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    editor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EditorConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-format-selection-json" tabindex="-1">3. Format Selection: JSON <a class="header-anchor" href="#_3-format-selection-json" aria-label="Permalink to &quot;3. Format Selection: JSON&quot;">​</a></h2><p>We will use standard <strong>JSON</strong> as the configuration format.</p><ul><li><strong>Primary Format</strong>: <code>config.json</code> (User/Project).</li><li><strong>Ecosystem</strong>: Universal support for syntax highlighting, linting, and automated tools.</li></ul><p><strong>Programmatic Edits:</strong> Since standard JSON does not support comments, we can safely use <code>serde_json</code> to serialize the <code>PartialConfig</code> layers back to disk when settings are changed via the UI.</p><h2 id="_4-minimal-persistence" tabindex="-1">4. Minimal Persistence <a class="header-anchor" href="#_4-minimal-persistence" aria-label="Permalink to &quot;4. Minimal Persistence&quot;">​</a></h2><p>To avoid &quot;setting drift&quot; (where user config accumulates defaults), we implement <strong>Delta Serialization</strong>:</p><p>When saving a setting (e.g., changing <code>tab_size</code> to 2 in Project scope):</p><ol><li><strong>Calculate Parent Value</strong>: Resolve <code>System + User</code>. Say the result is <code>4</code>.</li><li><strong>Compare</strong>: The new value <code>2</code> differs from <code>4</code>.</li><li><strong>Write Delta</strong>: We write <code>{&quot;editor&quot;: {&quot;tab_size&quot;: 2}}</code> to the Project layer file.</li></ol><p>If the user sets <code>tab_size</code> back to <code>4</code> (the parent value):</p><ol><li><strong>Compare</strong>: New value <code>4</code> equals parent <code>4</code>.</li><li><strong>Prune</strong>: We <em>remove</em> the <code>tab_size</code> key from the Project layer file, letting it inherit again.</li></ol><h2 id="_5-migration-strategy" tabindex="-1">5. Migration Strategy <a class="header-anchor" href="#_5-migration-strategy" aria-label="Permalink to &quot;5. Migration Strategy&quot;">​</a></h2><p>We will use <strong>Sequential Programmatic Migrations</strong> handled at load time.</p><ol><li><strong>Version Field</strong>: Every config file has a <code>version</code> field (default 0).</li><li><strong>Migrators</strong>: A chain of functions <code>fn migrate_v0_to_v1(serde_json::Value) -&gt; serde_json::Value</code>.</li><li><strong>Process</strong>: <ul><li>Load raw JSON file.</li><li>Apply <code>v0 -&gt; v1</code>, <code>v1 -&gt; v2</code>, etc., until <code>CURRENT_VERSION</code> is reached.</li><li>Deserialization into <code>PartialConfig</code> happens <em>after</em> migration.</li></ul></li></ol><h2 id="_6-conditional-configuration-layers" tabindex="-1">6. Conditional Configuration Layers <a class="header-anchor" href="#_6-conditional-configuration-layers" aria-label="Permalink to &quot;6. Conditional Configuration Layers&quot;">​</a></h2><p>To support advanced scenarios like platform-specific keybindings or language-specific indentation, we introduce <strong>Conditional Layers</strong> that are injected into the merge stack dynamically.</p><h3 id="platform-overrides" tabindex="-1">Platform Overrides <a class="header-anchor" href="#platform-overrides" aria-label="Permalink to &quot;Platform Overrides&quot;">​</a></h3><p>The editor will automatically look for and load platform-specific config files if they exist. These are merged <em>after</em> the main User config but <em>before</em> the Project config.</p><ul><li><code>config_linux.json</code></li><li><code>config_macos.json</code></li><li><code>config_windows.json</code></li></ul><p><strong>Resolution:</strong> <code>System -&gt; User -&gt; User(Platform) -&gt; Project -&gt; Session</code></p><h3 id="syntax-specific-overrides" tabindex="-1">Syntax-Specific Overrides <a class="header-anchor" href="#syntax-specific-overrides" aria-label="Permalink to &quot;Syntax-Specific Overrides&quot;">​</a></h3><p>When a buffer with a specific language ID (e.g., &quot;python&quot;) is active, the editor calculates an &quot;Effective Configuration&quot; for that buffer by injecting a language-specific layer.</p><p>This layer is derived from the <code>languages</code> key in the resolved config.</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// config.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;editor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;tab_size&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;languages&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;python&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;editor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;tab_size&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Explicit language override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;ruby&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;editor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;tab_size&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Resolution for a Buffer:</strong><code>EffectiveBufferConfig = Merge(GlobalConfig, LanguageConfig)</code></p><h2 id="implementation-plan" tabindex="-1">Implementation Plan <a class="header-anchor" href="#implementation-plan" aria-label="Permalink to &quot;Implementation Plan&quot;">​</a></h2><ol><li><strong>Refactor Config Structs</strong>: Split <code>Config</code> into <code>PartialConfig</code> (for layers) and <code>ResolvedConfig</code>.</li><li><strong>Implement Layer Loading</strong>: Update <code>config_io.rs</code> to load <code>System</code>, <code>User</code>, <code>Project</code> independently.</li><li><strong>Implement Merge Logic</strong>: Write a recursive merge function for <code>PartialConfig</code>.</li><li><strong>Update Save Logic</strong>: Ensure <code>save_to_file</code> calculates the delta against the merged parent layers.</li><li><strong>UI Integration</strong>: Update the Settings UI to modify the appropriate layer.</li></ol><h2 id="schema-validation" tabindex="-1">Schema Validation <a class="header-anchor" href="#schema-validation" aria-label="Permalink to &quot;Schema Validation&quot;">​</a></h2><p>We will continue to use <code>schemars</code> to generate JSON Schema. This provides out-of-the-box autocomplete and validation in most modern text editors.</p>`,47)])])}const k=t(n,[["render",l]]);export{p as __pageData,k as default};
